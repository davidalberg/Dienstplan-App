generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String      @id @default(cuid())
  email      String      @unique
  password   String
  name       String?
  role       String      @default("EMPLOYEE")
  employeeId String?     @unique
  teamId     String?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  auditLogs   AuditLog[]
  timesheets  Timesheet[]
  submissions MonthlySubmission[]
  employeeSignatures EmployeeSignature[]  // NEU: Multi-Employee-Signaturen
  team        Team?       @relation(fields: [teamId], references: [id])

  // Many-to-many: Assistenzkraft arbeitet für mehrere Klienten
  clients     Client[]

  // Neue Felder für Mitarbeiter-Verwaltung
  entryDate                DateTime?
  exitDate                 DateTime?
  hourlyWage               Float?       @default(0)
  travelCostType           String       @default("NONE")
  nightPremiumEnabled      Boolean      @default(true)
  nightPremiumPercent      Float        @default(25)
  sundayPremiumEnabled     Boolean      @default(true)
  sundayPremiumPercent     Float        @default(30)
  holidayPremiumEnabled    Boolean      @default(true)
  holidayPremiumPercent    Float        @default(125)

  // Dienstplan-Zuweisung
  assignedSheetId          String?
  assignedPlanTab          String?

  // Urlaubs-Integration
  vacationRequests    VacationRequest[] @relation("VacationRequests")
  vacationApprovals   VacationRequest[] @relation("VacationApprovals")
  vacationQuotas      VacationQuota[]
}

model Team {
  id                      String              @id @default(cuid())
  name                    String              @unique
  assistantRecipientEmail String?             // E-Mail des Assistenznehmers für Signatur
  assistantRecipientName  String?             // Name des Assistenznehmers für PDF
  clientId                String?
  timesheets              Timesheet[]
  members                 User[]
  submissions             MonthlySubmission[]
  client                  Client?             @relation(fields: [clientId], references: [id], onDelete: Cascade)
}

model Client {
  id           String    @id @default(cuid())
  firstName    String
  lastName     String
  email        String?
  phone        String?
  state        String?   // Bundesland
  isActive     Boolean   @default(true)
  displayOrder Int       @default(0)  // Für Sortierung/Reihenfolge
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  teams        Team[]
  employees    User[]           // Many-to-many: Assistenzkräfte die für diesen Klienten arbeiten
  submissions  TeamSubmission[] // Stundennachweise für diesen Klienten

  @@index([isActive])  // ✅ PERFORMANCE FIX: Für GET /api/clients mit isActive filter
}

model Timesheet {
  id               String   @id @default(cuid())
  date             DateTime
  plannedStart     String?
  plannedEnd       String?
  actualStart      String?
  actualEnd        String?
  breakMinutes     Int      @default(0)
  note             String?
  absenceType      String?
  status           String   @default("PLANNED")
  employeeId       String
  teamId           String?
  month            Int
  year             Int
  lastUpdatedAt    DateTime @updatedAt
  lastUpdatedBy    String?
  source           String?
  sheetFileName    String?
  sheetId          String?
  syncVerified     Boolean  @default(false)
  backupEmployeeId String?
  team             Team?    @relation(fields: [teamId], references: [id])
  employee         User     @relation(fields: [employeeId], references: [id])

  @@unique([employeeId, date])
  @@index([source, syncVerified])
  @@index([month, year, employeeId])
  @@index([date, status])
  @@index([backupEmployeeId, month, year])
  @@index([month, year, teamId])     // ✅ PERFORMANCE FIX: Für GET /api/admin/schedule mit teamId filter
  @@index([teamId, month, year])     // ✅ PERFORMANCE FIX: Alternative für team-based queries
}

model AuditLog {
  id         String   @id @default(cuid())
  employeeId String
  date       DateTime
  changedAt  DateTime @default(now())
  changedBy  String
  field      String?
  oldValue   String?
  newValue   String?
  employee   User     @relation(fields: [employeeId], references: [id])
}

model SyncLog {
  id            String    @id @default(cuid())
  startedAt     DateTime  @default(now())
  endedAt       DateTime?
  status        String
  message       String?
  rowsProcessed Int       @default(0)
}

model MonthlySubmission {
  id                 String    @id @default(cuid())
  month              Int
  year               Int
  employeeId         String
  teamId             String

  // Mitarbeiter-Signatur
  employeeSignature  String?   @db.Text // Base64 PNG
  employeeSignedAt   DateTime?
  employeeIp         String?

  // Assistenznehmer-Signatur
  recipientSignature String?   @db.Text // Base64 PNG
  recipientSignedAt  DateTime?
  recipientIp        String?
  signatureToken     String    @unique // Einmaliger Link-Token
  tokenExpiresAt     DateTime

  // PDF & Status
  pdfUrl             String?   // Google Drive URL
  status             String    @default("PENDING_EMPLOYEE")
  // Status: PENDING_EMPLOYEE → PENDING_RECIPIENT → COMPLETED

  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  employee           User      @relation(fields: [employeeId], references: [id])
  team               Team      @relation(fields: [teamId], references: [id])

  @@unique([employeeId, month, year])
  @@index([signatureToken])
  @@index([status])
}

// NEU: Konfiguration pro Dienstplan (sheetFileName)
model DienstplanConfig {
  id                      String           @id @default(cuid())
  sheetFileName           String           @unique // z.B. "Dienstplan Finn Jonschker 2026"
  assistantRecipientEmail String
  assistantRecipientName  String
  createdAt               DateTime         @default(now())
  updatedAt               DateTime         @updatedAt

  teamSubmissions         TeamSubmission[]

  @@index([sheetFileName])
}

// NEU: Team-basierte Einreichung (ersetzt MonthlySubmission für multi-employee)
model TeamSubmission {
  id                 String              @id @default(cuid())
  month              Int
  year               Int
  sheetFileName      String              // z.B. "Dienstplan Finn Jonschker 2026"
  dienstplanConfigId String?             // Optional für Legacy-Daten
  clientId           String?             // NEU: Direkte Klient-Zuordnung

  // Status: PENDING_EMPLOYEES → PENDING_RECIPIENT → COMPLETED
  status             String              @default("PENDING_EMPLOYEES")

  // Assistenznehmer-Signatur
  recipientSignature String?             @db.Text
  recipientSignedAt  DateTime?
  recipientIp        String?
  clientSignatureUrl String?             // NEU: Persistente URL für Klient-Unterschrift
  allEmployeesSigned Boolean             @default(false) // NEU: Performance-Cache für vollständige Team-Unterschriften

  // Token für Assistenznehmer-Link
  signatureToken     String              @unique
  tokenExpiresAt     DateTime

  // Finale PDF
  pdfUrl             String?
  googleDriveFileId  String?             // NEU: Google Drive Datei-ID

  // Admin manuelle Freigabe
  manuallyReleasedAt DateTime?
  manuallyReleasedBy String?
  releaseNote        String?

  // E-Mail Tracking
  lastReminderSentAt DateTime?           // NEU: Für 2-Tage Erinnerung

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  // Relations
  dienstplanConfig   DienstplanConfig?   @relation(fields: [dienstplanConfigId], references: [id])
  client             Client?             @relation(fields: [clientId], references: [id])
  employeeSignatures EmployeeSignature[]

  @@unique([sheetFileName, month, year])
  @@index([signatureToken])
  @@index([status])
  @@index([clientId, month, year])
  @@index([month, year])            // ✅ PERFORMANCE FIX: Für submissions overview ohne clientId filter
}

// NEU: Einzelne Mitarbeiter-Unterschriften innerhalb einer Team-Einreichung
model EmployeeSignature {
  id               String         @id @default(cuid())
  teamSubmissionId String
  employeeId       String

  // Token fuer E-Mail-Link
  signToken        String?        @unique
  tokenExpiresAt   DateTime?

  // Signatur-Daten (null bis unterschrieben)
  signature        String?        @db.Text // Base64 PNG
  signedAt         DateTime?
  ipAddress        String?

  createdAt        DateTime       @default(now())

  // Relations
  teamSubmission   TeamSubmission @relation(fields: [teamSubmissionId], references: [id], onDelete: Cascade)
  employee         User           @relation(fields: [employeeId], references: [id])

  @@unique([teamSubmissionId, employeeId])
  @@index([teamSubmissionId])
  @@index([employeeId])
  @@index([signToken])
}

// Aktivitätsprotokoll für System-Events und Debugging
model ActivityLog {
  id          String   @id @default(cuid())
  type        String   // INFO, WARNING, ERROR, SUCCESS
  category    String   // SHIFT, SUBMISSION, CLIENT, EMPLOYEE, SYSTEM
  action      String   // z.B. "Schicht erstellt", "Signatur hinzugefügt"
  details     String?  @db.Text // JSON mit zusätzlichen Details
  userId      String?  // Wer hat die Aktion ausgeführt
  userName    String?  // Cached Name für schnelle Anzeige
  entityId    String?  // ID des betroffenen Objekts
  entityType  String?  // Typ: Timesheet, User, Client, etc.
  createdAt   DateTime @default(now())

  @@index([createdAt])
  @@index([type])
  @@index([category])
}

// Urlaubsantrag - Integration mit Urlaubs-App
model VacationRequest {
  id           String    @id @default(cuid())
  employeeId   String
  startDate    DateTime
  endDate      DateTime
  status       String    @default("PENDING") // PENDING, APPROVED, REJECTED
  reason       String?
  firebaseId   String?   // Fuer Sync mit Urlaubs-App
  approvedBy   String?   // Admin der genehmigt hat
  approvedAt   DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  employee     User      @relation("VacationRequests", fields: [employeeId], references: [id], onDelete: Cascade)
  approver     User?     @relation("VacationApprovals", fields: [approvedBy], references: [id])

  @@index([employeeId])
  @@index([startDate, endDate])
  @@index([status])
}

// Urlaubskontingent pro Mitarbeiter und Jahr
model VacationQuota {
  id          String   @id @default(cuid())
  employeeId  String
  year        Int
  totalDays   Int      @default(30)
  usedDays    Float    @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  employee    User     @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([employeeId, year])
  @@index([year])
}
